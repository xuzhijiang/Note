# mysql索引的数据结构

    索引的定义就是: 索引是帮助mysql高效查询数据的数据结构.

![](../pics/索引可能用到的数据结构.png)

    结论: mysql索引使用的数据结构不是使用二叉树,而是使用B+tree这种数据结构.

# 为什么索引不使用hash这种数据结构?

    使用hash建立索引用的比较少,工作中99%是使用b+tree建立索引

    优点: 使用hash来建立索引,比如查找age=18的这一行的数据,只需要对18做哈希运算就可以得到这行数据在内存中的地址,
    磁盘io只需要一次(磁盘io是比较消耗性能的,所以只需要1次磁盘io性能已经很好了)

    缺点: 使用hash表建立索引有一个致命的缺点,那就是不能用于范围查询.你hash表性能再高,但是如果查找col1>6的行的话,hash表就没辙了.

# 为什么索引不使用二叉树这种数据结构?(二叉树作为索引的数据结构有什么问题?)

![](../pics/如果使用二叉树作为存储索引的数据结构,这里是使用col1作为索引.png)

    二叉树退化成链表后,时间复杂度从O(lgn) 退化为 O(n)
    
    使用二叉树的话,col1可能会退化成一条链,这种情况,并不能减少查询的次数.

# 为什么索引不使用红黑树(或者avl树)这种数据结构

    红黑树/avl平衡二叉树可以解决普通二叉树退化成链表的问题
    但是数据库也没有采用它作为索引的数据结构,主要原因：

    平衡树查找操作的时间复杂度和树高 h 相关,但是红黑树的出度为 2,树的高度无法控制,
    所以导致磁盘io会很多.(mysql数据是存放在磁盘上的,如果频繁从磁盘加载mysql数据的话,磁盘io肯定很高.)

# B树(Balance Tree多路平衡查找树)

    我们想要矮胖的树,而不是瘦高的树,树的高度越高,查找次数就越多,磁盘io就越多,系统性能会下降.这就引出了B树.

>注意: 没有B减树(B-tree,这个是B树,不是B减树)

    红黑树的出度为 2，而B树的出度一般都非常大，所以相同节点数量,
    B树大比红黑树的树高 h 很明显低多，IO查找的次数也就少很多.

![](../pics/b树结构.png)

    0. B树是在平衡二叉树的基础之上改进过来的(满足左小右大).
    1. B树的每个节点能存放的元素比二叉树多.就是为了降低树的高度.控制io操作的次数.
        相比于平衡二叉树,B树解决了树的高度不会太高的问题
    2. 也就是存储同样个数的节点,B树的高度比平衡二叉树的低很多.

![](../pics/二叉树为什么比B树查询的磁盘io更多呢.png)

![](../pics/二叉树为什么比B树查询的磁盘io更多呢02.png)
    
    B树的特点:

![](../pics/b树的特点.png)

    B树的非叶子节点除了存储索引,也存储数据
    
    B+树对这个特点进行了改造,使得非叶子节点可以存储更多的索引元素,这样树的高度就可以更低了
    
    B树的范围查询查询效率太低了(或者说不支持范围查找),因为节点不是冗余存储的

    应用: B树在大块数据的读上有明显的优势,所以普遍运用于数据库和文件系统.

# B+tree(加强版多路平衡查找树)

    为了解决B树范围查询效率太低的问题,出现了B+树.
    
    B+树继承了B树的优点:
        - 每个节点中能存放的元素比较多,所以能够减少磁盘io的次数
    
    B+树的范围查询效率非常高,因为叶子节点之间是通过链表相连,是顺序排列的.

![](../pics/B+树的样子.png)

    B+树的一个节点存储了很多元素,mysql官方给每个节点设置了大小限制默认大概为16K,
    可以通过这个命令查看: show global status like 'Innodb_page_size'; 

![](../pics/b+tree每个节点存储多少个索引元素01.png)

    按照上图推算:
        1. 我们一般使用主键索引假如使用bitint.占用8个字节.
        2. 然后指向下一层的指针占用大概6个字节
        3. 所以一个元素占用: 6+8=14个字节.
        4. 所以一个非叶子节点大概可存放16Kb/14b=1170个

        B+树中,data存放在叶子节点.非叶子节点不存储data.
        非叶子节点只存储部分索引(冗余存储)

![](../pics/b+tree每个节点存储多少个索引元素02.png)

    叶子节点存放的了data,这个data可能存放的是索引所在行的地址指针
    ,也有可能是索引所在行的数据.这个要看是什么引擎.
    
    所以一个叶子节点对应的索引大概总大小是1KB(包含了data的大小),
    
    所以一个节点可以存放16Kb/1Kb=16个索引元素.
    
    整个树可以存放大概: 1170*1170*16=2千多万

![](../pics/b+tree每个节点存储多少个索引元素03.png)

![](../pics/b+tree每个节点存储多少个索引元素04.png)

![](../pics/高度为3的B+树为什么只2次磁盘io就可以找打数据.png)

    一般b+tree的高度要控制在2-4之间,这样磁盘io的次数就可以控制.
    如果树的高度再高,也就是数据量再大的话,就要分库分表.

![](../pics/b+tree是如何满足范围查询的.png)

    插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，
    需要对树进行一个分裂、合并、旋转等操作来维护平衡性

# 参考

- [视频](https://www.bilibili.com/video/av70678432?p=5)
